Задача: Динамическая загрузка модулей

Ты разрабатываешь систему плагинов для приложения.
Каждый плагин представляет собой отдельный .jar файлик, который должен быть загружен и выполнен динамически.
Реализуй систему, которая:

1. Читает список доступных плагинов из конфигурационного файла/либо сделай хардкод этих систем
2. Загружает каждый плагин в отдельном ClassLoader(пример кода ниже покажет как)
3. Инициирует и запускает основную логику каждого плагина, вызывая специально определенный метод (например, execute()).

Каждый плагин должен быть написан как отдельный Java-проект, компилироваться в .jar файл и подключаться к основному приложению через classpath(либо cp).

Шаблон решения:

1. Определение интерфейса плагина:
   Создай интерфейс Plugin, который будет определять метод execute(), который каждый плагин должен реализовать.

   public interface Plugin {
   void execute();
   }

2. Реализация плагинов:
   Напиши несколько плагинов, реализующих интерфейс Plugin.
   Например:

   public class FormattingPlugin implements Plugin {
   @Override
   public void execute() {
   System.out.println("FormattingPlugin is executing...");
   // Если нужно можешь дополнить чем-нибудь логику каждого плагина
   }
   }


3. Создание основного приложения:
   Напиши основное приложение, которое будет загружать и запускать плагины.
   Используй URLClassLoader https://docs.oracle.com/javase/8/docs/api/java/net/URLClassLoader.html
   для динамической загрузки .jar файлов.

   import java.net.URL;
   import java.net.URLClassLoader;
   import java.util.List;

   public class MainApplication {
   public static void main(String[] args) throws Exception {
   // Список путей к .jar файлам плагинов (можно хардкод оставить, можно загрузить из конфигурационного файла)
   List<String> pluginJarPaths = List.of("plugin1.jar", "plugin2.jar");

           // Загрузка каждого плагина
           for (String jarPath : pluginJarPaths) {
               URL jarUrl = new URL("file://" + jarPath);
               URLClassLoader classLoader = new URLClassLoader(new URL[]{jarUrl});

               // Загрузка класса плагина
               Class<?> pluginClass = classLoader.loadClass("com.example.FormattingPlugin");

               // Создание экземпляра плагина
               Plugin plugin = (Plugin) pluginClass.getDeclaredConstructor().newInstance();

               // Запуск плагина
               plugin.execute();

               // Закрытие класслоадера
               classLoader.close();
           }
       }
   }

4. Сборка и запуск:
   Собери каждый плагин в отдельный .jar файл. Укажи пути к этим .jar файлам в pluginJarPaths программного кода. Затем запусти MainApplication, чтобы увидеть, как каждый плагин выполняет свою логику.

Когда ты выполняешь задачу, демонстрирующую использование ClassLoader для динамической загрузки классов из .jar файлов и их подключения к основному приложению через classpath, ты сможешь понять несколько важных аспектов.


1) поймешь, что ClassLoader в Java играет ключевую роль в загрузке классов во время выполнения программы. Он позволяет тебе загружать классы не только из основного приложения, но и из внешних .jar файлов, что дает гибкость в расширении функциональности приложения.

2) увидишь, как можно динамически загружать классы из внешних .jar файлов и исполнять их в контексте основного приложения. Это демонстрирует, как можно добавлять новый функционал или изменять существующий без необходимости перекомпиляции или перезапуска приложения.

3) увидишь как ClassLoader может быть применен на практике кастомно в твоих целях

4) проработаешь механизмы сборки джаров